import { AbortError, assert } from 'errors';

/**
 * Runs a given async function again and again unless cancelled or AbortError is thrown by this function.
 * New calls to loop are discarded.
 * Both returned function and promise it returns have "cancel: () => void" and "running: boolean" properties.
 * @param {function} task
 * @param {function} [cancelTask] Callback to .cancel()
 * @returns {() => Promise<void>}
 */
export function loop(
  task = () => Promise.reject(new AbortError()),
  cancelTask = () => {}
) {
  let running = false;
  let currentLoop = Promise.resolve();

  /**
   * Calls provided task again and again while running is true or error is thrown by task
   * @returns {Promise<void>}
   */
  const runTask = async () => {
    let taskReturnValue;
    try {
      while (running) {
        taskReturnValue = await task(taskReturnValue);
      }
    } catch (err) {
      assert(err instanceof AbortError, err);
    } finally {
      running = false;
    }
    return taskReturnValue;
  };

  /** Stops the loop, calls the cancelTask callback */
  const cancel = () => {
    running = false;
    cancelTask(task);
  };

  /**
   * Extends provided object with cancel and running properties
   * @type {<T>(o: T) => T}
   */
  const withLoopProps = o =>
    Object.assign(o, {
      cancel,
      get running() {
        return running;
      },
    });

  /** Starts the task loop if possible */
  const returnValue = () => {
    if (running === false) {
      running = true;
      currentLoop = withLoopProps(runTask());
    }
    return currentLoop;
  };

  return withLoopProps(returnValue);
}
