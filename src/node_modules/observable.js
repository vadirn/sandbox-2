/**
 * @typedef Observable
 * @property {<T>(fn: (currentValue: T) => void) => () => void} subscribe Runs given function whenever set function is called
 * @property {<T>(newValue: T) => void} set Sets value of observable and iterates through subscribers
 * @property {*} current Current observable value
 */

/**
 * @typedef ReadonlyObservable
 * @property {(fn: (currentValue: T) => void) => () => void} subscribe Runs given function whenever set function is called
 * @property {*} current Current observable value
 */

/**
 * Creates observable value
 * @type {<T>(initialValue: T) => Observable}
 */
export function observable(initialValue) {
  let currentValue = initialValue;
  const subscribers = [];

  const iterateSubscribers = value => {
    subscribers.slice().forEach(s => s(value));
  };

  const subscribe = fn => {
    subscribers.push(fn);
    fn(currentValue);
    return () => {
      const index = subscribers.indexOf(fn);
      if (index >= 0) {
        subscribers.splice(index, 1);
      }
    };
  };

  const set = newValue => {
    currentValue = newValue;
    iterateSubscribers(currentValue);
  };

  return {
    subscribe,
    set,
    get current() {
      return currentValue;
    },
  };
}

/**
 * Combines given observables into a new one
 * @param  {...(Observable|ReadonlyObservable)} observables
 * @returns {ReadonlyObservable}
 */
export function combined(...observables) {
  const value = observable();
  const set = () => value.set(observables.map(o => o.current));
  const unsubscribers = observables.map(o => o.subscribe(set));

  return {
    subscribe: value.subscribe,
    complete: () => {
      observables.forEach(o => o.complete?.());
      unsubscribers.forEach(u => u());
    },
    get current() {
      return value.current;
    },
  };
}

/**
 * Creates a new observable from a given one by applying a mapper function to its value
 * @param {(Observable|ReadonlyObservable)} o
 * @param {function} mapper
 * @returns {ReadonlyObservable}
 */
export function derived(o, mapper) {
  const value = observable();
  const unsubscribe = o.subscribe(newValue => value.set(mapper(newValue)));

  return {
    subscribe: value.subscribe,
    complete: () => {
      o.complete?.();
      unsubscribe();
    },
    get current() {
      return value.current;
    },
  };
}

/**
 * Sets value of observable if it is different from the current one
 * @param {observable} o
 * @param {*} newValue
 */
export function setChanged(o, newValue) {
  if (o.current !== newValue) {
    o.set(newValue);
  }
}
